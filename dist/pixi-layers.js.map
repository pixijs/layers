{"version":3,"file":"pixi-layers.js","sources":["../src/DisplayMixin.ts","../src/RendererMixin.ts","../src/Group.ts","../src/Layer.ts","../src/Stage.ts","../src/index.ts"],"sourcesContent":["import { DisplayObject, Container } from '@pixi/display';\n\n/** @ignore */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function generateLayerContainerRenderMethod(originalRender: any)\n{\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    return function render(renderer: any): void\n    {\n        if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\n        {\n            return;\n        }\n\n        if (!this.visible)\n        {\n            this.displayOrder = 0;\n\n            return;\n        }\n\n        this.displayOrder = renderer.incDisplayOrder();\n\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        renderer._activeLayer = null;\n        originalRender.call(this, renderer);\n        renderer._activeLayer = this._activeParentLayer;\n    };\n}\n\n// special case - container render method, because we want it to be faster\n/**\n * @internal\n * @private\n * @ignore\n */\nfunction containerRender(renderer: any): void\n{\n    if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\n    {\n        return;\n    }\n\n    if (!this.visible)\n    {\n        this.displayOrder = 0;\n\n        return;\n    }\n\n    this.displayOrder = renderer.incDisplayOrder();\n\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    renderer._activeLayer = null;\n    this.containerRenderWebGL(renderer);\n    renderer._activeLayer = this._activeParentLayer;\n}\n\nexport function applyDisplayMixin(): void\n{\n    if (DisplayObject.prototype.displayOrder !== undefined)\n    {\n        return;\n    }\n\n    (Object as any).assign(DisplayObject.prototype, {\n        parentLayer: null,\n        _activeParentLayer: null,\n        parentGroup: null,\n        zOrder: 0,\n        zIndex: 0,\n        updateOrder: 0,\n        displayOrder: 0,\n        layerableChildren: true,\n        isLayer: false\n    });\n\n    const ContainerProto = Container.prototype as any;\n\n    ContainerProto.containerRenderWebGL = ContainerProto.render;\n    ContainerProto.render = containerRender;\n}\n\n/** Apply mixin to your custom Container class (not needed if using built-in {@link PIXI.Container})\n * Call it for `myClass.prototype`, not for `myClass` !\n * */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function applyContainerRenderMixin(CustomRenderContainer: any): void\n{\n    if (CustomRenderContainer.originalRenderWebGL)\n    {\n        return;\n    }\n\n    CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.render;\n    CustomRenderContainer.render = generateLayerContainerRenderMethod(CustomRenderContainer.render);\n\n    if (CustomRenderContainer.renderCanvas)\n    {\n        CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.renderCanvas;\n        CustomRenderContainer.renderCanvas = generateLayerContainerRenderMethod(CustomRenderContainer.renderCanvas);\n    }\n}\n\n/** Apply mixin for particles */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function applyParticleMixin(ParticleContainer: any): void\n{\n    ParticleContainer.prototype.layerableChildren = false;\n    applyContainerRenderMixin(ParticleContainer.prototype);\n}\n","import { IRenderableObject, IRendererRenderOptions, Renderer } from '@pixi/core';\nimport { Container } from '@pixi/display';\n// import { LayersTreeSearch } from './LayersTreeSearch';\nimport { generateLayerContainerRenderMethod } from './DisplayMixin';\n\nimport type { Stage } from './Stage';\nimport type { Layer } from './Layer';\n\n/**\n * Mixin applied on {@link PIXI.Renderer} when using @pixi/layers.\n */\ninterface ILayeredRenderer\n{\n    /** Order/index of last rendered object */\n    _lastDisplayOrder: number;\n\n    /** {@link Layer} currently being rendered */\n    _activeLayer: Layer;\n\n    /** **Internal** method for updating {@link ILayeredRenderer#_lastDisplayOrder} */\n    incDisplayOrder(): number;\n\n    /** **Internal** reference to old render method */\n    _oldRender(displayObject: IRenderableObject, options?: IRendererRenderOptions): void;\n}\n\nexport type { ILayeredRenderer };\n\n/**\n * @internal\n * @ignore\n */\nfunction generateLayerRendererMethod(_oldRender: any)\n{\n    return function render(displayObject: IRenderableObject, options: any, arg1?: any, arg2?: any, arg3?: any)\n    {\n        if (!options || (!options.renderTexture && !options.baseTexture))\n        {\n            this._lastDisplayOrder = 0;\n        }\n        this._activeLayer = null;\n\n        if ((displayObject as Stage).isStage)\n        {\n            (displayObject as Stage).updateStage();\n        }\n        // if (this.plugins.interaction && !this.plugins.interaction.search.worksWithLayers)\n        // {\n        //     this.plugins.interaction.search = new LayersTreeSearch();\n        // }\n\n        _oldRender.call(this, displayObject, options, arg1, arg2, arg3);\n    };\n}\n\n/**\n * Mixes {@link ILayeredRenderer} into {@link PIXI.Renderer}.\n *\n * This is automatically done on importing @pixi/layers.\n */\nexport function applyRendererMixin(rendererClass: typeof Renderer): void\n{\n    const RendererProto = rendererClass.prototype as (Renderer & Partial<ILayeredRenderer>);\n\n    // Skip if mixin already applied.\n    if (RendererProto._oldRender)\n    {\n        return;\n    }\n\n    Object.assign(RendererProto, {\n        _lastDisplayOrder: 0,\n        _activeLayer: null,\n        incDisplayOrder()\n        {\n            return ++this._lastDisplayOrder;\n        },\n        _oldRender: Renderer.prototype.render,\n    });\n\n    RendererProto._oldRender = RendererProto.render;\n    RendererProto.render = generateLayerRendererMethod(RendererProto.render);\n}\n\n/**\n * Mixes renderer mixin + container mixin for canvas.\n *\n * If you are using PixiJS' canvas renderer, you'll need to invoke this manually.\n *\n * @example\n * import { CanvasRenderer } from '@pixi/canvas-renderer';\n * import { applyCanvasMixin } from '@pixi/layers';\n *\n * applyCanvasMixin(CanvasRenderer);\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function applyCanvasMixin(canvasRenderClass: any): void\n{\n    if (!canvasRenderClass)\n    {\n        // eslint-disable-next-line max-len,no-console\n        console.log('@pixi/layers: Canvas mixin was called with empty parameter. Are you sure that you even need this line?');\n\n        return;\n    }\n\n    applyRendererMixin(canvasRenderClass);\n\n    const ContainerProto = Container.prototype as any;\n\n    if (ContainerProto.containerRenderCanvas)\n    {\n        return;\n    }\n\n    ContainerProto.containerRenderCanvas = ContainerProto.renderCanvas;\n    ContainerProto.renderCanvas = generateLayerContainerRenderMethod(ContainerProto.renderCanvas);\n}\n\n","import { utils } from '@pixi/core';\n\nimport type { DisplayObject } from '@pixi/display';\nimport type { Layer } from './Layer';\nimport type { Stage } from './Stage';\n\n/**\n * A context for z-ordering {@link PIXI.DisplayObject}s within the same {@link Layer}.\n * @memberof PIXI.layers\n */\nexport class Group extends utils.EventEmitter\n{\n    static _layerUpdateId = 0;\n\n    /** See {@link Layer#useRenderTexture} */\n    public useRenderTexture = false;\n\n    /** See {@link Layer#useDoubleBuffer} */\n    public useDoubleBuffer = false;\n\n    /**\n     * Groups with a non-zero sort priority are sorted first.\n     *\n     * Unsure of the exact purpose yet :)\n     */\n    public sortPriority = 0;\n\n    /** See {@link Layer#clearColor} */\n    public clearColor : ArrayLike<number> = new Float32Array([0, 0, 0, 0]);\n\n    // TODO: handle orphan groups\n    // TODO: handle groups that don't want to be drawn in parent\n    canDrawWithoutLayer = false;\n    canDrawInParentStage = true;\n\n    /** Default zIndex value for layers that are created with this Group */\n    public zIndex: number;\n\n    /** Enabling sorting objects within this group by {@link PIXI.DisplayObject#zOrder zOrder}. */\n    public enableSort: boolean;\n\n    private _activeLayer: Layer = null;\n    private _activeStage: Stage = null;\n    /** @private */\n    _activeChildren: Array<DisplayObject> = [];\n    private _lastUpdateId = -1;\n\n    /**\n     * @param zIndex - The z-index for the entire group.\n     * @param sorting - This will enable sorting by z-order. You can also pass a callback that will assign\n     *  the z-index _before_ sorting. This is useful, for example, when you want to sort by \"y\" - the callback\n     *  can then set the {@link PIXI.DisplayObject#zOrder zOrder} to the y-coordinate. This callback is invoked\n     *  as an event-listener to the {@link Group#sort} event.\n     */\n    constructor(zIndex = 0, sorting: boolean | ((displayObject: DisplayObject) => void) = false)\n    {\n        super();\n\n        this.zIndex = zIndex || 0;\n        this.enableSort = !!sorting;\n\n        if (typeof sorting === 'function')\n        {\n            this.on('sort', sorting);\n        }\n    }\n\n    doSort(layer: Layer, sorted: Array<DisplayObject>): void\n    {\n        if ((this.listeners as any)('sort', true))\n        {\n            for (let i = 0; i < sorted.length; i++)\n            {\n                this.emit('sort', sorted[i]);\n            }\n        }\n\n        sorted.sort(Group.compareZIndex);\n    }\n\n    private static compareZIndex(a: DisplayObject, b: DisplayObject): number\n    {\n        if (a.zOrder < b.zOrder)\n        {\n            return -1;\n        }\n        if (a.zOrder > b.zOrder)\n        {\n            return 1;\n        }\n\n        return a.updateOrder - b.updateOrder;\n    }\n\n    /**\n     * clears temporary variables\n     */\n    private clear(): void\n    {\n        this._activeLayer = null;\n        this._activeStage = null;\n        this._activeChildren.length = 0;\n    }\n\n    /**\n     * Resolve a child {@link PIXI.DisplayObject} that is set to be in this group.\n     *\n     * This is an **internal** method.\n     *\n     * @see Stage#updateStage\n     * @private\n     */\n    _resolveChildDisplayObject(stage: Stage, displayObject: DisplayObject): void\n    {\n        this.check(stage);\n        displayObject._activeParentLayer = this._activeLayer;\n\n        if (this._activeLayer)\n        {\n            this._activeLayer._activeChildren.push(displayObject);\n        }\n        else\n        {\n            this._activeChildren.push(displayObject);\n        }\n    }\n\n    /**\n     * Resolve the layer rendering this group of {@link DisplayObject display objects}.\n     *\n     * This is an **internal** method.\n     *\n     * @see Layer#_onBeginLayerSubtreeTraversal\n     * @private\n     */\n    _resolveLayer(stage: Stage, layer: Layer): void\n    {\n        this.check(stage);\n\n        if (this._activeLayer)\n        {\n            Group.conflict();\n        }\n\n        this._activeLayer = layer;\n        this._activeStage = stage;\n    }\n\n    private check(stage: Stage): void\n    {\n        if (this._lastUpdateId < Group._layerUpdateId)\n        {\n            this._lastUpdateId = Group._layerUpdateId;\n            this.clear();\n            this._activeStage = stage;\n        }\n        else if (this.canDrawInParentStage)\n        {\n            let current = this._activeStage;\n\n            while (current && current !== stage)\n            {\n                current = current._activeParentStage;\n            }\n            this._activeStage = current;\n            if (current === null)\n            {\n                this.clear();\n            }\n        }\n    }\n\n    private static _lastLayerConflict = 0;\n\n    /** Log a conflict that occurs when multiple layers render the same group. */\n    private static conflict(): void\n    {\n        if (Group._lastLayerConflict + 5000 < Date.now())\n        {\n            Group._lastLayerConflict = Date.now();\n            // eslint-disable-next-line max-len,no-console\n            console.log(`@pixi/layers found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it`);\n        }\n    }\n\n    /**\n     * Fired for each {@link DisplayObject} in this group, right before they are sorted.\n     *\n     * @event sort\n     * @param {PIXI.DisplayObject} object - The object that will be sorted.\n     */\n}\n","import { Container } from '@pixi/display';\nimport { Group } from './Group';\nimport { settings, Rectangle, RenderTexture, Renderer } from '@pixi/core';\n\nimport type { DisplayObject, IDestroyOptions } from '@pixi/display';\nimport type { Stage } from './Stage';\nimport type { ILayeredRenderer } from './RendererMixin';\n\n/**\n * This manages the render-texture a {@link Layer} renders into.\n *\n * This is used internally by {@link Layer#render}.\n * @memberof PIXI.layers\n */\nexport class LayerTextureCache\n{\n    constructor(public layer: Layer) {}\n\n    private renderTexture: RenderTexture = null;\n    private doubleBuffer: Array<RenderTexture> = null;\n    private currentBufferIndex = 0;\n    _tempRenderTarget: RenderTexture = null;\n    _tempRenderTargetSource = new Rectangle();\n    _tempRenderTargetDestination = new Rectangle();\n\n    private init(renderer?: Renderer): void\n    {\n        const width = renderer ? renderer.screen.width : 100;\n        const height = renderer ? renderer.screen.height : 100;\n        const resolution = renderer ? renderer.resolution : settings.RESOLUTION;\n\n        this.renderTexture = RenderTexture.create({ width, height, resolution });\n\n        if (this.layer.group.useDoubleBuffer)\n        {\n            this.doubleBuffer = [\n                RenderTexture.create({ width, height, resolution }),\n                RenderTexture.create({ width, height, resolution })\n            ];\n        }\n    }\n\n    /** See {@link Layer#getRenderTexture}. */\n    getRenderTexture(): RenderTexture\n    {\n        if (!this.renderTexture)\n        {\n            this.init();\n        }\n\n        return this.renderTexture;\n    }\n\n    /** Prepares the layer's render-texture and set it as the render-target. */\n    pushTexture(renderer: Renderer): void\n    {\n        // TODO: take not screen, but offset screen, in case there's matrix transform\n        const screen = renderer.screen;\n\n        if (!this.renderTexture)\n        {\n            this.init(renderer);\n        }\n\n        const rt = this.renderTexture;\n        const group = this.layer.group;\n        const db = this.doubleBuffer;\n\n        if (rt.width !== screen.width\n            || rt.height !== screen.height\n            || rt.baseTexture.resolution !== renderer.resolution)\n        {\n            rt.baseTexture.resolution = renderer.resolution;\n            rt.resize(screen.width, screen.height);\n\n            if (db)\n            {\n                db[0].baseTexture.resolution = renderer.resolution;\n                db[0].resize(screen.width, screen.height);\n                db[1].baseTexture.resolution = renderer.resolution;\n                db[1].resize(screen.width, screen.height);\n            }\n        }\n\n        if (db)\n        {\n            db[0].framebuffer.multisample = rt.framebuffer.multisample;\n            db[1].framebuffer.multisample = rt.framebuffer.multisample;\n        }\n\n        this._tempRenderTarget = renderer.renderTexture.current;\n        this._tempRenderTargetSource.copyFrom(renderer.renderTexture.sourceFrame);\n        this._tempRenderTargetDestination.copyFrom(renderer.renderTexture.destinationFrame);\n\n        renderer.batch.flush();\n\n        if (group.useDoubleBuffer)\n        {\n            // double-buffer logic\n            let buffer = db[this.currentBufferIndex];\n\n            if (!(buffer.baseTexture as any)._glTextures[renderer.CONTEXT_UID])\n            {\n                renderer.renderTexture.bind(buffer, undefined, undefined);\n                renderer.texture.bind(buffer);\n                if (group.clearColor)\n                {\n                    renderer.renderTexture.clear(group.clearColor as any);\n                }\n            }\n            renderer.texture.unbind(rt.baseTexture);\n            (rt.baseTexture as any)._glTextures = (buffer.baseTexture as any)._glTextures;\n            (rt.baseTexture as any).framebuffer = (buffer.baseTexture as any).framebuffer;\n\n            buffer = db[1 - this.currentBufferIndex];\n            renderer.renderTexture.bind(buffer, undefined, undefined);\n        }\n        else\n        {\n            // simple logic\n            renderer.renderTexture.bind(rt, undefined, undefined);\n        }\n\n        if (group.clearColor)\n        {\n            renderer.renderTexture.clear(group.clearColor as any);\n        }\n\n        // fix for filters\n        const filterStack = renderer.filter.defaultFilterStack;\n\n        if (filterStack.length > 1)\n        {\n            filterStack[filterStack.length - 1].renderTexture = renderer.renderTexture.current;\n        }\n    }\n\n    /** Flushes the renderer and restores the old render-target. */\n    popTexture(renderer: Renderer): void\n    {\n        renderer.batch.flush();\n        renderer.framebuffer.blit();\n        // switch filters back\n        const filterStack = renderer.filter.defaultFilterStack;\n\n        if (filterStack.length > 1)\n        {\n            filterStack[filterStack.length - 1].renderTexture = this._tempRenderTarget;\n        }\n        renderer.renderTexture.bind(this._tempRenderTarget,\n            this._tempRenderTargetSource, this._tempRenderTargetDestination);\n        this._tempRenderTarget = null;\n\n        const rt = this.renderTexture;\n        const group = this.layer.group;\n        const db = this.doubleBuffer;\n\n        if (group.useDoubleBuffer)\n        {\n            renderer.texture.unbind(rt.baseTexture);\n            this.currentBufferIndex = 1 - this.currentBufferIndex;\n\n            const buffer = db[this.currentBufferIndex];\n\n            (rt.baseTexture as any)._glTextures = (buffer.baseTexture as any)._glTextures;\n            (rt.baseTexture as any).framebuffer = (buffer.baseTexture as any).framebuffer;\n        }\n    }\n\n    /** Destroy the texture-cache. Set {@link Layer.textureCache} to {@code null} after destroying it! */\n    destroy(): void\n    {\n        if (this.renderTexture)\n        {\n            this.renderTexture.destroy();\n            if (this.doubleBuffer)\n            {\n                this.doubleBuffer[0].destroy(true);\n                this.doubleBuffer[1].destroy(true);\n            }\n        }\n    }\n}\n\n/**\n * A {@link Layer layer} can be used to render {@link PIXI.DisplayObject}s in a different part of the scene graph together.\n *\n * A layer can be used to structure a scene graph in a data-oriented manner and separate the z-ordering hierarchy in\n * a different tree. Each layer is associated with a {@link Group} that provides the context for sorting objects\n * in the same layer.\n *\n * All layers must be placed underneath a {@link Stage} - generally, you should assign a {@link Stage} as your\n * scene's root.\n * @memberof PIXI.layers\n */\nexport class Layer extends Container\n{\n    /** Flags that this container is a layer! */\n    public readonly isLayer = true;\n\n    /** The group of {@link DisplayObject}s that are rendered within this layer */\n    public group: Group = null;\n\n    /** The texture manager used when rendering into a {@link Layer#useRenderTexture layer render-texture}. */\n    public textureCache: LayerTextureCache;\n\n    _activeChildren: Array<DisplayObject> = [];\n    _tempChildren: Array<DisplayObject> = null;\n    _activeStageParent: Stage = null;\n    _sortedChildren: Array<DisplayObject> = [];\n    _tempLayerParent: Layer = null;\n\n    insertChildrenBeforeActive = true;\n    insertChildrenAfterActive = true;\n\n    /**\n     * @param group - The group of {@link DisplayObject}s to be rendered by this layer.\n     */\n    constructor(group: Group = null)\n    {\n        super();\n\n        if (group)\n        {\n            this.group = group;\n            this.zIndex = group.zIndex;\n        }\n        else\n        {\n            this.group = new Group(0, false);\n        }\n\n        this._tempChildren = this.children;\n    }\n\n    /**\n     * Flags whether this layer should render into a render-texture.\n     *\n     * This is useful if you want to use the layer as a texture elsewhere - for example, in sprites or to apply\n     * filters. The layer's render-texture is resized to the size of the renderer's screen.\n     */\n    get useRenderTexture(): boolean\n    {\n        return this.group.useRenderTexture;\n    }\n    set useRenderTexture(value: boolean)\n    {\n        this.group.useRenderTexture = value;\n    }\n\n    /**\n     * This will enable double buffering for this layer.\n     *\n     * This layer will keep two render-textures to render into - choosing one each frame on a flip-flop\n     * basis. This is useful when you\n     *\n     * **Caveat**: You must enable {@link Layer#useRenderTexture} to prevent framebuffer errors in rendering.\n     */\n    get useDoubleBuffer(): boolean\n    {\n        return this.group.useDoubleBuffer;\n    }\n    set useDoubleBuffer(value: boolean)\n    {\n        this.group.useDoubleBuffer = value;\n    }\n\n    /**\n     * The background color to clear the layer.\n     *\n     * This should be used when {@link Layer#useRenderTexture} is enabled.\n     */\n    get clearColor(): ArrayLike<number>\n    {\n        return this.group.clearColor;\n    }\n    set clearColor(value: ArrayLike<number>)\n    {\n        this.group.clearColor = value;\n    }\n\n    get sortPriority(): number\n    {\n        return this.group.sortPriority;\n    }\n    set sortPriority(value: number)\n    {\n        this.group.sortPriority = value;\n    }\n\n    /**\n     * The rendering {@link Layer#useRenderTexture into a render-texture} is enabled, this will return\n     * the render-texture used by this layer.\n     */\n    getRenderTexture(): RenderTexture\n    {\n        if (!this.textureCache)\n        {\n            this.textureCache = new LayerTextureCache(this);\n        }\n\n        return this.textureCache.getRenderTexture();\n    }\n\n    /**\n     * you can override this method for this particular layer, if you want\n     */\n    public doSort(): void\n    {\n        this.group.doSort(this, this._sortedChildren);\n    }\n\n    /** @override */\n    public destroy(options?: IDestroyOptions): void\n    {\n        if (this.textureCache)\n        {\n            this.textureCache.destroy();\n            this.textureCache = null;\n        }\n\n        super.destroy(options);\n    }\n\n    /** @override */\n    public render(renderer: Renderer): void\n    {\n        if (!this.prerender(renderer as any))\n        {\n            return;\n        }\n\n        if (this.group.useRenderTexture)\n        {\n            if (!this.textureCache)\n            {\n                this.textureCache = new LayerTextureCache(this);\n            }\n            this.textureCache.pushTexture(renderer);\n        }\n\n        this.containerRenderWebGL(renderer);\n        this.postrender(renderer as any);\n\n        if (this.group.useRenderTexture)\n        {\n            this.textureCache.popTexture(renderer);\n        }\n    }\n\n    /**\n     * renderCanvas named this way because of some TS mixin problem\n     * @param renderer\n     */\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    public layerRenderCanvas(renderer: any): void\n    {\n        if (this.prerender(renderer))\n        {\n            this.containerRenderCanvas(renderer);\n            this.postrender(renderer);\n        }\n    }\n\n    /**\n     * This should be called when the layer is found while traversing the scene for updating object-layer association.\n     *\n     * This is an **internal** method.\n     *\n     * @see Stage#updateStage\n     * @private\n     */\n    _onBeginLayerSubtreeTraversal(stage: Stage): void\n    {\n        // This will transfer all \"_activeChildren\" of \"this.group\" into \"this._activeChildren\". This is done\n        // because a DisplayObject in that group may be placed before the layer in the scene tree.\n\n        const active = this._activeChildren;\n\n        this._activeStageParent = stage;\n        this.group._resolveLayer(stage, this);\n        const groupChildren = this.group._activeChildren;\n\n        active.length = 0;\n        for (let i = 0; i < groupChildren.length; i++)\n        {\n            groupChildren[i]._activeParentLayer = this;\n            active.push(groupChildren[i]);\n        }\n        groupChildren.length = 0;\n    }\n\n    /**\n     * This should be called when the full subtree of the layer has been traversed while updating the stage's scene.\n     *\n     * This is an **internal** method.\n     *\n     * @see Stage#updateStage\n     * @private\n     */\n    _onEndLayerSubtreeTraversal(): void\n    {\n        const children = this.children;\n        const active = this._activeChildren;\n        const sorted = this._sortedChildren;\n\n        for (let i = 0; i < active.length; i++)\n        {\n            this.emit('display', active[i]);\n        }\n\n        sorted.length = 0;\n        if (this.insertChildrenBeforeActive)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                sorted.push(children[i]);\n            }\n        }\n        for (let i = 0; i < active.length; i++)\n        {\n            sorted.push(active[i]);\n        }\n        if (!this.insertChildrenBeforeActive\n            && this.insertChildrenAfterActive)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                sorted.push(children[i]);\n            }\n        }\n\n        if (this.group.enableSort)\n        {\n            this.doSort();\n        }\n    }\n\n    /**\n     * Prepares the renderer for this layer.\n     *\n     * It will assign {@link PIXI.Renderer#_activeLayer} to {@code this}, and set the active layer before\n     * this to {@link Layer#_activeParentLayer _activeParentLayer}. It will also temporarily sort the\n     * children by z-order.\n     *\n     * @return `true`, if the layer needs to be rendered; `false`, when the layer is invisible or has\n     * zero alpha.\n     */\n    protected prerender(renderer: ILayeredRenderer): boolean\n    {\n        // eslint-disable-next-line eqeqeq\n        if (this._activeParentLayer && this._activeParentLayer != renderer._activeLayer)\n        {\n            return false;\n        }\n\n        if (!this.visible)\n        {\n            this.displayOrder = 0;\n\n            return false;\n        }\n\n        this.displayOrder = renderer.incDisplayOrder();\n\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (this.worldAlpha <= 0 || !this.renderable)\n        {\n            return false;\n        }\n\n        // we are making a hack with swapping children, it can go wrong easily\n        // this is special \"recover\" if that allows stage to recover just after failed frame\n\n        if (this.children !== this._sortedChildren\n            && this._tempChildren !== this.children)\n        {\n            this._tempChildren = this.children;\n        }\n\n        // just a temporary feature - getBounds() for filters will work with that\n        // TODO: make a better hack for getBounds()\n\n        (this as any)._boundsID++;\n        (this as any).children = this._sortedChildren;\n\n        this._tempLayerParent = renderer._activeLayer;\n        renderer._activeLayer = this;\n\n        return true;\n    }\n\n    /**\n     * Cleans up the renderer after this layer is rendered.\n     *\n     * It restores {@link Renderer#_activeLayer} to the parent layer and restores the canonical\n     * order of children.\n     */\n    protected postrender(renderer: ILayeredRenderer): void\n    {\n        (this as any).children = this._tempChildren;\n        renderer._activeLayer = this._tempLayerParent;\n        this._tempLayerParent = null;\n    }\n}\n\n(Layer.prototype as any).renderCanvas = Layer.prototype.layerRenderCanvas;\n","import { Container, DisplayObject } from '@pixi/display';\nimport { Layer } from './Layer';\nimport { Group } from './Group';\n\n/**\n * The {@link Stage stage} manages all the layers in its scene tree.\n *\n * @memberof PIXI.layers\n */\nexport class Stage extends Layer\n{\n    static _updateOrderCounter = 0;\n\n    /** Flags that this is a {@link Stage stage}! */\n    public readonly isStage = true;\n\n    _tempGroups: Array<DisplayObject> = [];\n\n    /**\n     * Found layers\n     * @private\n     */\n    _activeLayers: Array<Layer> = [];\n\n    _activeParentStage: Stage = null;\n\n    /**\n     * clears all display lists that were used in last rendering session\n     * please clear it when you stop using this displayList, otherwise you may have problems with GC in some cases\n     */\n    clear(): void\n    {\n        this._activeLayers.length = 0;\n        this._tempGroups.length = 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    destroy(options?: any): void\n    {\n        this.clear();\n        super.destroy(options);\n    }\n\n    /**\n     * This should be called before rendering for resolving items in the scene tree to their {@link Layer layers}.\n     *\n     * If your scene's root is a {@link Stage}, then the {@link ILayerRenderer} mixin will automatically\n     * call it.\n     */\n    updateStage(): void\n    {\n        this._activeParentStage = null;\n        Group._layerUpdateId++;\n        this._updateStageInner();\n    }\n\n    private updateAsChildStage(stage: Stage): void\n    {\n        this._activeParentStage = stage;\n        Stage._updateOrderCounter = 0;\n        this._updateStageInner();\n    }\n\n    private _updateStageInner(): void\n    {\n        this.clear();\n        this._addRecursive(this);\n        const layers = this._activeLayers;\n\n        for (let i = 0; i < layers.length; i++)\n        {\n            const layer = layers[i];\n\n            if (layer.group.sortPriority)\n            {\n                layer._onEndLayerSubtreeTraversal();\n                const sorted = layer._sortedChildren;\n\n                for (let j = 0; j < sorted.length; j++)\n                {\n                    this._addRecursiveChildren(sorted[j]);\n                }\n            }\n        }\n\n        for (let i = 0; i < layers.length; i++)\n        {\n            const layer = layers[i];\n\n            if (!layer.group.sortPriority)\n            {\n                layer._onEndLayerSubtreeTraversal();\n            }\n        }\n    }\n\n    private _addRecursive(displayObject: DisplayObject): void\n    {\n        if (!displayObject.visible)\n        {\n            return;\n        }\n\n        if ((displayObject as any).isLayer)\n        {\n            const layer = displayObject as any as Layer;\n\n            this._activeLayers.push(layer);\n            layer._onBeginLayerSubtreeTraversal(this);\n        }\n\n        if (displayObject !== this && (displayObject as any).isStage)\n        {\n            const stage = displayObject as Stage;\n\n            stage.updateAsChildStage(this);\n\n            return;\n        }\n\n        displayObject._activeParentLayer = null;\n        let group = displayObject.parentGroup;\n\n        if (group)\n        {\n            group._resolveChildDisplayObject(this, displayObject);\n        }\n        const layer = displayObject.parentLayer;\n\n        if (layer)\n        {\n            group = layer.group;\n            group._resolveChildDisplayObject(this, displayObject);\n        }\n\n        displayObject.updateOrder = ++Stage._updateOrderCounter;\n        if (displayObject.alpha <= 0 || !displayObject.renderable\n            || !displayObject.layerableChildren\n            || (group && group.sortPriority))\n        {\n            return;\n        }\n\n        const children = (displayObject as Container).children;\n\n        if (children && children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._addRecursive(children[i]);\n            }\n        }\n    }\n\n    private _addRecursiveChildren(displayObject: DisplayObject): void\n    {\n        if (displayObject.alpha <= 0 || !displayObject.renderable\n            || !displayObject.layerableChildren)\n        {\n            return;\n        }\n        const children = (displayObject as Container).children;\n\n        if (children && children.length)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._addRecursive(children[i]);\n            }\n        }\n    }\n}\n","/* eslint-disable spaced-comment */\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path=\"../global.d.ts\" />\n\nimport { applyDisplayMixin, applyContainerRenderMixin, applyParticleMixin } from './DisplayMixin';\nimport { applyRendererMixin, applyCanvasMixin } from './RendererMixin';\nimport { Renderer } from '@pixi/core';\n\nimport type { ILayeredRenderer } from './RendererMixin';\n\nexport * from './Stage';\nexport * from './Layer';\nexport * from './Group';\n\nexport { applyDisplayMixin, applyCanvasMixin, applyContainerRenderMixin, applyRendererMixin, applyParticleMixin };\nexport type { ILayeredRenderer };\n\napplyDisplayMixin();\napplyRendererMixin(Renderer);\n\n/**\n * @namespace PIXI.layers\n */\n\n/**\n * @namespace PIXI\n */\n\n/**\n * PixiJS base class.\n * @class PIXI.DisplayObject\n * @see https://pixijs.download/release/docs/PIXI.DisplayObject.html\n */\n\n/**\n * The {@link PIXI.layers.Group group} in which this display object should be rendered.\n *\n * This is provided by **@pixi/layers**.\n *\n * @memberof PIXI.DisplayObject\n * @member {PIXI.layers.Group}\n * @name parentGroup\n */\n\n/**\n * The {@link PIXI.layers.Layer layer} in which this display object should be rendered; don't set this if you're\n * using {@link PIXI.DisplayObject#parentLayer}.\n *\n * This is provided by **@pixi/layers**.\n *\n * @memberof PIXI.DisplayObject\n * @member {PIXI.layers.Layer}\n * @name parentLayer\n */\n\n/**\n * Objects in a {@link PIXI.layers.Group group} are sorted by z-order.\n * This can be used alongside PixiJS' built-in {@link PIXI.DisplayObject#zIndex zIndex}.\n *\n * If you use both {@code zIndex} and {@code zOrder}, objects will first be sorted by z-index\n * and then @pixi/layers will sort by z-order.\n *\n * This is provided by **@pixi/layers**.\n *\n * @memberof PIXI.DisplayObject\n * @member {number}\n * @name zOrder\n */\n"],"names":["generateLayerContainerRenderMethod","originalRender","renderer","containerRender","applyDisplayMixin","DisplayObject","ContainerProto","Container","applyContainerRenderMixin","CustomRenderContainer","applyParticleMixin","ParticleContainer","generateLayerRendererMethod","_oldRender","displayObject","options","arg1","arg2","arg3","applyRendererMixin","rendererClass","RendererProto","Renderer","applyCanvasMixin","canvasRenderClass","_Group","utils","zIndex","sorting","layer","sorted","i","a","b","stage","current","Group","LayerTextureCache","Rectangle","width","height","resolution","settings","RenderTexture","screen","rt","group","db","buffer","filterStack","Layer","value","active","groupChildren","children","_Stage","layers","j","Stage"],"mappings":"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"}